---
title: "Tutorial for updating hypotheses using the GORIC(A)"
author: "Rebecca M. Kuiper"
date: "19-7-2021"
fontsize: 14pt
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
knitr::opts_chunk$set(comment = NA,warning=FALSE)
```

This is a tutorial for updating hypotheses and calculating the GORIC(A).
It uses the goric() function of the restriktor package to calculate the GORIC and the GORICA.


Two examples will be used:

1. The first is based on Monin and Holubar, a replication study of Monin. Here, the study of Monin is used to update the explortaory hypotheses used Monin to theory-based, order-restricted hypotheses for Holubar. By examining these, one can check whether Holubar replicated the findings of Monin or not. Both these studies use an ANOVA model.
2. The second example is based on Altinisik et al.. Here, theory-based hypotheses are based on theories and on previous findings. In this example, the GORICA is applied to the results of a logistic regression model.
At the end, there if code to automatically create all possible explorative hypotheses, which can be helpful when there are a lot of parameters.



# Load libraries

We need to load the required libraries (after they have been installed). These libraries contain functions, such as `goric`, that will be used in the R code below.
Each time you reopen R, you will have to load the required libraries.

```{r, message = FALSE, warning = FALSE}
## First, we need to install the packages, if you have not done this already:
if (!require("psych")) install.packages("psych")
if (!require("restriktor")) install.packages("restriktor")

## Then, load the packages:
library(psych) # for the function describeBy
library(restriktor) # for the goric function
```


# Example 1: ANOVA
In this example, the study of Monin will be used to render order-constrained hypotheses for the Holubar study, which is a (direct) replication study of Monin. 
For this, we will do an exploratory analysis on the Monin data and inspect the sample means.

## Load data of Monin
Notably, it is only possible to load the data if you are using the correct working directory (with both your R script and data file). The command `getwd()` shows you your current working directory. You can change the working directory to the one you prefer using the function `setwd()` by specifying the correct location between parentheses. Alternatively, in Rstudio, you can use the "Session" tab (on top) or you can use the "Files"-pane (on top of probably the right lower box of your Rstudio-screen, this pane is located next to the panes for "Plots", "Packages", "Help" and "Viewer").

If you open the data file `Data_Monin.txt` in a text editor, you can see that the variable labels have been inserted (using quotes; i.e., "...") in the first line of the file, which is called a header. Therefore, you have to specify 'header = TRUE' when loading the data:

```{r}
# Load the data
Monin <- read.table("Data_Monin.txt", header = TRUE)
```


Since we loaded a .txt file, R does not know the measurement levels of the variables and assumes all of them to be continuous, meaning that they are of interval or ratio type. Hence, we need to tell R that the variable `group` is a factor by using the `factor()` function over the `group` variable (i.e., a grouping / categorical / nominal variable):  

```{r}
# Make the variable group a factor
Monin$group <- factor(Monin$group) 
```

To inspect the dataset, use:

```{r}
head(Monin) # Look at first (6) rows of the data
```

If you want a more detailed overview of the data, by means of descriptive statistics split by `group`, use

```{r}
descrstat <- describeBy(Monin$attract, Monin$group, mat = TRUE)
descrstat
```


## Model Selection using GORIC on Monin data
First, we need an R-object with unconstrained estimates, that is, in this example, the group means and one residual variance.

```{r}
lm_fit_Monin <- lm(attract ~ group - 1, data = Monin)
```

Note that:

  1. `y ~ group - 1` instructs the function `lm` (linear model) to regress y on group.
  
  2. The `- 1` instructs the function `lm` to drop the intercept and, therefore, estimate the means in each group, resulting here in three group means. 
On the other hand,  `y ~ group' would estimate an intercept, representing the mean of the reference group, and the mean differences between the other (here, two) groups and the reference group.
  
  3. The results are collected in, what is called, an R-object, named `lm_fit_Monin`.



Let's check the names used in this model.

```{r}
names(coef(lm_fit_Monin))
```
  
 
### Set of exploratory hypotheses for Monin
On the Monin data set, we are going to do an exploratory analysis, which means that we are going to use all combinations with equalities (and no restrictions). We will specify all possibilities knowing that:

  * It is possible to use the following operators: `>`, `<`, `=`, `== `,`<=`or`>=` within the `restriktor()` and `goric()` functions 
      + `==` operator is interpreted in the same fashion as the `=`, meaning an equality  
      + `<=` and `>=` operators are interpreted as respectively: `<` and `>` by the code

  * The `goric()` and the `restriktor` functions can deal with:
      + pairwise restrictions (eg. "x1>x2;x2==x3" also equivalent to "x1>x2;x2=x3")
      + combined with more than one operators restrictions(eg. "x1>x2==x3" also equivalent to "x1>x2=x3")
      
It is important to remember that all restrictions within one hypothesis has to be separated with a semicolon `;`.

```{r}
H00 <- 'group1 == group2 == group3'
H01 <- 'group1 == group2'
H02 <- 'group1 == group3'
H03 <- 'group2 == group3'
```

In case there are many possibilities, you do not want to write these out. In that case, use automated code, as given at the end of this tutorial.(Note: The code is programmed to generate the pairwise restrictions)


### Calculate GORIC(A) values and weights for Monin
In the calculation of the GORIC, an iterative process is needed to calculate the penalty / complexity part. Therefore, one needs to set a seed value:

1. Then, you will obtain the same penalty value every time you run this code.

2. Then, you can change the seed value to check the sensitivity of the penalty value. If it is sensitive, then increase number of iterations used in calculation of the penalty (see below).

```{r}
set.seed(123) # Set seed value
goric(lm_fit_Monin, H00, H01, H02, H03)
```

It can be seen that $H_01$ ($\mu_1 = \mu_2, \mu_3$) receives the most support. Based on the means (see `descrstat`), where we see that $\mu_1$ and $\mu_2$ are both larger than $\mu_3$, we will evaluate the following hypothesis in the Holubar data: $$H_1: \mu_1 = \mu_2 > \mu_3.$$
Since $H_u$ obtained some support as well, we could specify (using the sample means of the Monin data) thw following competing hypothesis: $$H_2: \mu_2 > \mu_1 > \mu_3.$$


In case you want to use the GORICA values and weights instead, use:

```{r, eval = FALSE}
set.seed(123) # Set seed value
goric(lm_fit_Monin, H0, H1, H2, H3, type = "gorica")
```


## Load data of Holubar (replication study)
First, we have to read in the Holubar dataset, and tell R that the variable `gr` (group) is a factor instead of a continuous variable.

```{r}
Holubar <- read.table("Data_Holubar.txt", header = TRUE) # load the data
Holubar$gr <- factor(Holubar$gr) # tell R that gr is a factor
```

If you want a more detailed overview of the data, also by means of descriptive statistics splitted by `group`, use

```{r}
head(Holubar)

descrstat <- describeBy(Holubar$at, Holubar$gr, mat = TRUE)
descrstat
```

Then, we fit an ANOVA-model by means of the `lm`-function (linear model) and directly check the names that are used in this model:
```{r}
lm_fit_Holubar <- lm(at ~ gr - 1, data = Holubar)
names(coef(lm_fit_Holubar))
```

### Set of hypotheses for Holubar based on results of Monin
Based on the results and sample means of Monin, we created two competing hypotheses: 
```{r}
H1 <- 'gr1 == gr2; gr2 > gr3' # Note: we cannot use gr1 == gr2 > gr3
H2 <- 'gr2 > gr1; gr1 > gr3'  # Note: we cannot use gr2 > gr1 > gr3
```

### Calculate GORIC(A) values and weights for Holubar
```{r}
set.seed(123) # Set seed value
output_repl <- goric(lm_fit_Holubar, H1, H2)
summary(output_repl)
```
Since the support for $H_1$ and $H_2$ is lower than for $H_u$, both are weak hypotheses. Hence, the study of Holubar did not replicate the findings of Monin.


In case you are only interested in the 'main hypothesis' $H_1$ found in Monin, you could also evaluate this against its complement:
```{r}
set.seed(123) # Set seed value
goric(lm_fit_Holubar, H1, comparison = "complement")
```
Since $H_1$ has only 0.39 (lower than 1) times more support than its complement, it is a weak hypothesis. Hence, the study of Holubar did not replicate the findings of Monin.


Notably, in case you want to use the GORICA, you can use the following commands:
```{r, eval = FALSE}
set.seed(123) # Set seed value
goric(lm_fit_Holubar, H0, H1, H2, type = "gorica")
```
When you want to calculate the GORICA for $H_1$ and its complement, use:
```{r, eval = FALSE}
set.seed(123) # Set seed value
goric(lm_fit_Holubar, H1, type = "gorica", comparison = "complement")
```



# Example 1: Logistic regression example
In this example, the order-constrained hypotheses for a replication data set are based on the results of the original study and based on theories from two previous studies.
More details can be found in Altinisik et al (unpublished).
Since we cannot share the data, we will use the estimates of the parameters of interest and their covariance matrix. Therefore, we can only determined the GORICA.

## Load data 
The estimates of structural parameters (i.e., the parameters of interest, that is, the parameters used in the hypotheses) are
```{r}
est <- c(0.4765484,  0.2759022,  0.8669835, -0.4430030,  0.8066336, -0.2462610)
names(est) <- c("RS_Gr1", "RSES_Gr1", "RS_Gr2", "RSES_Gr2", "RS_Gr3", "RSES_Gr3")
```
Notably, the parameters need to be labelled such that those can be used in specifying the hypotheses.

Their covariance matrix is:
```{r}
VCOV <- matrix(c(
 0.1736427, -0.1736427,  0.0000000,  0.0000000,  0.0000000,  0.0000000,
-0.1736427,  0.6325835,  0.0000000,  0.0000000,  0.0000000,  0.0000000,
 0.0000000,  0.0000000,  0.2094106, -0.2094106,  0.0000000,  0.0000000,
 0.0000000,  0.0000000, -0.2094106,  0.3740883,  0.0000000,  0.0000000,
 0.0000000,  0.0000000,  0.0000000,  0.0000000,  0.1351709, -0.1351709,
 0.0000000,  0.0000000,  0.0000000,  0.0000000, -0.1351709,  0.1829996), byrow = TRUE, ncol = 6)
```
Notably, the covariance matrix does not need to be labelled.

### Set of hypotheses based on theories and findings from previous studies
Note that we use the names we used as labels above.
```{r}
H1 <- "RS_Gr1 + RSES_Gr1 == 0; RS_Gr1 > 0;
       RS_Gr2 + RSES_Gr2 == 0; RS_Gr2 > 0;
       RSES_Gr3 == 0; RS_Gr3 > 0"
H2 <- "RS_Gr1 + RSES_Gr1 == 0; RS_Gr1 > 0;
       RSES_Gr2 == 0; RS_Gr2 == 0;
       RSES_Gr3 == 0; RS_Gr3 > 0"
```


### Calculate GORICA values and weights
```{r}
set.seed(123)
output_gorica_Altinisik <- goric(est, H1, H2, VCOV = VCOV, type = "gorica")
summary(output_gorica_Altinisik)
```
It can be seen that both $H_1$ and $H_2$ are not weak hypotheses and that $H_1$ is the preferrerd one: It is 3.65 times more supported than $H_2$.
Hence, the support for these theories is also found in this replication and based on this replication study we conclude that $H_1$ is more supported.



# Autmated way of making all explortaory (=) restrictions / constraints 
```{r}
#make columns per number of variables in hypothesis
h <- paste(names(coef(lm_fit_Monin)), " == 0")
col <- NULL
for(i in 1:length(h)){
  col <- c(col, combn(h, i, FUN = function(x){return(paste(x, collapse = '; '))}))
}
hypotheses <- data.frame(col)
#make dataframe without the missings and split in two columns
if (!require("tidyr")) install.packages("tidyr") # install this package first (once)
library(tidyr)
hypotheses <- gather(hypotheses, na.rm = TRUE, factor_key = TRUE)
#all hypothesis in text, by R
hypotheses$value
#number of hypotheses
nrhypos <- sum(!is.na(hypotheses$value))
#create all hypotheses H01 to H0nrhypos
for(i in 1:nrhypos){
  assign(paste("H0", i, sep = ""), hypotheses$value[i])    
}
# Now all the exploratory (=) hypotheses are specified

# In case you want to see them all, use this:
cat(paste0("H0", 1:nrhypos, ";"))
# and past result in R console and you see them.

# paste result from following into goric function
cat(paste0("H0", 1:nrhypos, ","))
```




[//]: #The following line is needed to prevent R Markdown from including a lot of white space below the last content.
<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>